### Java类实现序列化，为什么要设置serialVersionUID
- Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传来的字节流中serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同则认为是一致的，否则就会出现序列化版本不一致的异常，即InvaidCastException.
- serialVersionUID有两种显示的生成方式：
- 默认1L private static final long serialVersionUID = 1L；
- 根据类名、接口名、成员方法及属性来生成一个64位的哈希字段。
- 显示定义的好处：
    - 即使某个类在与之对应的对象，已经序列化除去后做了修改，该对象依然可以被正确反序列化
- 不显示定义的坏处：
    - 该属性值将由JVM根据类的相关信息计算，序列化之后，修改了类，就会造成反序列化的失败；
    - 不利于程序在不同的JVM之间的移植，不同平台JVM不同，出现因类版本不兼容而无法正确反序列化的现象出现。
### 线程创建方式
- 1.直接继承Thread类；
- 2.实现Runnable接口，然后将它传递给Thread的构造函数；
- 3.实现Callable接口，重写call()方法
    - Callable在任务结束后可以提供一个返回值，runnable无法提供；
    - Callable中的call方法可以抛出异常，而Runnable中的run不能抛出异常；
    - 运行callable可以拿到一个Futrue对象，Future对象可以表示异步计算的结果，也可以当做检测计算是否结束的方法。
### 多线程实现同步锁的实现方法有哪些
- 同步代码块、同步方法、Lock锁机制
- 由于synchronize是在JVM层面实现的，因此系统可以监控锁的释放与否，而ReentrantLock是使用代码层面实现的，系统无法自动释放，需要在finally字句中显示释放lock.unlock();
- 在使用synchronized代码块时，可以与wait()/notify()/notifyAll()一起使用，从而进一步实现线程的通信。wait方法会释放占有的对象锁，当前线程进入等待池，释放CPU，而其他正在等待的线程即可抢占此锁，线程的sleep方法则表示，当前线程会休眠一段时间，休眠期间，会暂时释放CPU，但并不释放对象锁；notify方法会唤醒因为调用对象的wait而处于等待的线程，从而使得该线程有机会获取对象锁，wait和notify必须在synchronized代码块中调用。notifyAll是唤醒所有的线程
### Java四种引用介绍及使用场景
- 强引用-FinalReference
- 介绍：强引用是平常中使用最多的引用，强引用在程序内存不足(OOM)的时候也不会被回收.
```
String str = new String("str");
```
- 软引用-SoftReference
- 介绍：软引用在程序内存不足的时，会被收回，使用方式
```// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```
- 使用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。
- 弱引用-WeakReference
- 介绍：弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：
    ```Java
    WeakReference<String> wrf = new WeakReference<String>(str);
    ```
- 虚引用-PhantomReference
- 介绍：虚引用的回收机制跟弱引用差不多，但是它在回收之前，会被放入referenceQueue中，其他引用是被JVM回收后才被传入Reference中的，由于这个机制，所以虚引用大多被用于引用销毁前的处理工作，还有就是，虚引用创建的时候，必须带有ReferenceQueue。
    ```Java
    PhantomReference<String> prf = new PhantomReference<String>(new String("str"), new ReferenceQueue<>());
    ```
- 上述所说的四类引用，都是指对象本身的引用。
### JVM中GC垃圾回收机制与垃圾回收算法
- 1.运行时内存区
    - 虚拟机中内存分布以及管理，运行时数据区分为方法区、堆、虚拟机栈、本地方法栈和程序计数器等。
    - 方法区：线程共享的内存区域，用来存储类加载的信息、常量、静态变量、即时编译器编译后的代码等。其中方法区中有个经常会用到的区域叫做运行时常量池，主要用于存储一些常量，当创建一个常量时，首先会在运行时常量池查看是否有，有则直接使用，否则重新创建
    - 堆：是最大的一块内存区域，也是垃圾回收管理的主要区域，主要用于存放对象实例；
    - 程序计时器：线程是私有的，每个线程都会分配一个线程计时器，用来表示当前线程执行的字节码的行号指示器；
    - 虚拟机栈：虚拟机栈主要存储基本数据类型变量和引用类型变量。栈区的句柄指向堆区的对象实例。
    - 本地方法栈：与虚拟机栈意义相似，区别在于虚拟机栈用于使用Java方法，而本地方法栈是针对于Native方法服务。
- 2.内存分配与回收策略
    - 创建一个对象，首先会在eden区域分配区域，如果内存不够，就会将年龄大的转移到Survivor区域，若Survivor区域存储不下，则会转移年老代（Tenured）。对于一些静态变量不需要使用对象调用的，则会放入到永生代。一般长期存活的对象最终会被存放到年老代，还有一种创建大对象时，比如数据这种需要申请连续空间的，如果空间较大，则会直接进入年老代。
    - 在回收过程中，有一个参数比较重要，就是对象的年龄，如果在一次垃圾回收过程中有使用该对象时，则将对象年龄加1，否则减1，当计数为0，则进行回收，如果年龄达到某一数字则进入老生代。总的来说内存分配机制主要体现在对象创建之后是否仍在使用，已经不使用的回收，继续使用的对年龄进行更新，达到一定程度，转移到年老代。
- 3.垃圾回收算法
    - 1.标记-清除算法：该算法先标记，后清除，将所有需要回收的对象进行标记，然后清除，缺点：效率低，标记清除后有大量碎片，碎片太多可能会使存储大对象时候触发GC回收，造成内存浪费以及时间的消耗。
    - 2.复制算法：将可用内存分成两份，每次使用其中一份，当这块回收之后把未回收的复制到另一块内存中，然后把使用的那块清除。优点：算法运行简单，解决了标记清除的碎片问题，缺点：这种算法代价过高，需要将可用内存缩小一半，对象存活率较高时，需要持续复制工作，效率较低。
    - 3.标记整理算法：是针对复制算法在对象存活率较高时只需复制导致效率较低的缺点进行改进的，该算法在标记-清除算法基础上，不直接清理，而是使存活对象往一端走，然后清除一端边界以外的内存，这样就避免不连续空间出现，还可以避免存活率较高时的持续复制。这种算法适合老生代。
    - 4.分代收集算法
        - 这是目前虚拟机使用的回收算法，将内存分为各个年代，在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以使用标记整理算法。


### 1.简述JNI(Java Native Interface:Java本地接口)
- JNI是Java和C语言之间的桥梁，由于Java是一种解释语言，可以被反编译出来，一些重要涉及安全的代码就使用了C语言，再者很多底层功能调用C语言都实现了Java没必要重复造轮子，所以定义的JNI接口。
### 2.简述NDK(Native Develop Kit: 本地开发)
- Android NDK是一套允许您使用原生代码语言（例如C和C++）实现部分应用的工具集。在开发类型应用时，这有助于您重复使用以这些语言编写的代码库。
### 3.为什么使用NDK：
- 1.在平台之间移植其应用；
- 2.重复使用现在库，或者提供自己的库重复使用；
- 3.因为C或C++是编译型语言，可以提高应用性能；
- 4.使用第三方库，现在许多第三方库都是由C/C++库编写的，比如Ffmpeg这样库；
- 5.不依赖于Dalvik java虚拟机的设计；
- 6.代码保护，Java层代码很容易被反编译，而C/C++库反编译难度大。解释：Java被编译为一种中间形式的JVM字节码，保留了原始Java代码中包含的大量信息。像C++这样的语言编译成汇编代码，看起来跟原始代码差别较大，因为很难被反编译。
### 4.简述TCP，UDP，Socket
- TCP是经过3次握手，4次挥手完成一串数据的传送
- 3次握手：第一次，建立连接时，客户端发送syn包到服务器，进入SYN_SEND状态，等待服务器确认；第二次：服务器收到syn包，发送syn+ack包，ack是回应包；第三次：客户端收到服务器syn+ack包后，向服务器发送确认包，此包发送完毕后，客户端和服务端进入ESTABLISHED状态（TCP连接状态），完成三次握手。 帮助理解：两个商人想做货物交易，第一次握手：商人A给商人B发了一封邮件说明了自己的意愿，第二次握手：商人B收到邮件后，回复商人A自己收到了邮件，并期待合作，第三次握手：商人A又回复B说，等我消息；
- 4次挥手：第一次：客户端发出连接释放报文，并停止发送数据；第2次：服务器收到报文，进入关闭等待状态（close-wait），向客户端发送确认消息；第三次：服务器发出释放报文；第四次：客户端确认；
- UDP是User Datagram Protocol的简称，中文名：用户数据报协议，是一种无连接、无状态的传输层协议，提供面向事务的简单不可靠信息传送服务；优点：传输快，一对多，相对安全；缺点：不可靠不稳定，数据传递时容易丢包；
- Socket协议 网络上的两个程序通过一个双向的连接实现数据的交换，这个连接的一端称为一个socket，socket本质是变成接口（API），对TCP/Ip的封装，
View的分发机制，滑动冲突、
- View的事件传递顺序有3个重要方法，dispatchTouchEvent()是否消费了本次事件，onInterceptTouchevent()是否拦截了本次事件，onTouchEvent()是否处理本次事件，滑动冲突分为同方向
### 类的加载机制
- JVM把class文件加载到内存，并对数据进行校验、解析、初始化。解析：虚拟机常量池内的符号引用替换为直接引用的过程。（比如String s ="aaa",转化为 s的地址指向"aaa"的地址）初始化：执行类构造方法的过程。
### Java反射机制
- 反射就是将类中的方法、成员变量、构造方法，抽象出来可以让Class 的对象单独进行访问。
- 概括：使用反射可以赋予jvm动态编译的能力，否则类的元数据信息只能用静态编译的方式实现，运行时确定类型，绑定对象，动态编译最大限度地发挥了Java的灵活性，体现了多态的应用，降低了类之间的耦合性。（多态存在三个必要条件：继承、重写、父类引用指向子类对象）
### 序列化、反序列化到底是什么
- 对象序列化：把Java对象转换成字节码序列并存储在储存媒介（硬盘或内存）的过程；
- 对象的反序列化：把字节序列恢复为Java对象的过程。
- Java对象存在的前提必须在JVM运行期间，Java对象序列化由于Java对象已经保存在存储媒介上，所以在Java对象可能不存在的情况下依然可以使用。
- 为什么要有序列化和反序列化：开发中有在JVM非运行状态或者在其他机器JVM上获取指定Java对象的需求。
- Android中Serializable与Parcelable区别：存储媒介的不同，前者存硬盘，或者存内存中，内存读写速度更快，android通常优先选择Parcelable。
### 动态代理
- 之所以称为代理工厂，是因为此处的代理类与目标类完全解耦，任何实现了某一个接口的类，都可以把此类当做生产代理类的工厂，代理工厂类中使用java.lang.reflect.Proxy的newProxyInstance(arg…)方法返回一个代理的对象；因此动态代理是针对实现接口的类生成代理类的，故也称接口代理。
### HashMap原理分析
- Hash中文名散列，是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值，这种转换是一种压缩映射。例如int i = (n-1)&hash.
- JDK1.8之后，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值8时，将链表转换为红黑树，这样大大减少了查找时间。
- HashMap实现原理，当添加一个元素时，就首先计算元素key的hash值,计算方法如下：
```Java
// ^异或：如果相对应位值相同，则结果为0，否则为1
(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
```
并以此确定key的在数组中的位置，
```Java
// i 为数组下标，使用位运算&，执行效率更高，&如果对应位上都为1，值为一，否则为0
int i = (n - 1) & hash;

```
但是可能存在同一hash值的元素已经放在同一位置了，这时就添加到同一hash值的后面，这样就形成了链表，同一个链表上的Hash值时相同的，所以说数组存放的时链表，而当链表长度太长时，链表就转换为红黑树，提升效率。
- 源码中的数据域：加载因子默认0.75，如果填充比很大则说明空间利用很多，如果不扩容则会导致链表越来越长，查找效率会越来越低
- HashMap红黑树解决问题方式：如果某个位桶的记录过大时（默认链表长度为8时），HashMap会动态的使用一个专门的treemap实现来替换链表，这样做效率更高，时O(logn),而不是糟糕的O(n);
    - 具体工作原理：使用Hash值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里，如果哈希值相等，HashMap希望key值最好实现了comparable接口的，这样他可以按照顺序进行插入。
### Java注解
- java.lang.annotation.Annotation 本身是接口，而不是注解，当使用关键字@interface定义一个注解时，该注解隐含继承了Annotation接口，定义注解只能依靠@interface实现；
- 自定义注解，需要添加元注解；Java元注解@Retention @Target @Document @Inherited;
    - @Retention
    ```    
    @Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含
    @Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，
    @Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到
    ```
    - @Target
    ```
    @Target(ElementType.TYPE) //接口、类、枚举、注解
    @Target(ElementType.FIELD) //字段、枚举的常量
    @Target(ElementType.METHOD) //方法
    @Target(ElementType.PARAMETER) //方法参数
    @Target(ElementType.CONSTRUCTOR) //构造函数
    @Target(ElementType.LOCAL_VARIABLE)//局部变量
    @Target(ElementType.ANNOTATION_TYPE)//注解
    @Target(ElementType.PACKAGE) ///包
    ```
### 关于二叉树的前序、中序、后序遍历；
- 前序顺序：根节点排最前，然后同级先左后右；
- 中序顺序：先左后根在右
- 后续顺序：先左后右最后根
- 个人观点：前序中序后序的名字由来，就是根节点的位置；

- 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
- 二叉树遍历分为三种：前序、中序、后序，其中序遍历最为重要。为啥叫这个名字？是根据根节点的顺序命名的。
    - 前序顺序：根节点排最先，然后同级先左后右；
    - 中序顺序：根节点排中间，即先左后根再右；
    - 后序顺序：根节点在最后，即先左后右在根节点；

![图片说明](C:\Users\Mr Halo\Desktop\二叉树.png) 
- 上图二叉树遍历结果：
    - 前序遍历：ABCDEFGHK

    - 中序遍历：BDCAEHGKF

    - 后序遍历：DCBHKGFEA
- 例子前序遍历：先根节点，再左右
    - A->B 找到左节点B，此时B被任命为根节点，去查找它的子节点；
    - B->C 找到右节点C,将C任命为根节点；
    - C->D 找到左节点D，结束左树查找。
- 例子中序遍历左子树：先左后根再右；
    - B->D B无左节点，所以第一个节点为B，然后在到C节点，由于C存在左节点D，所以先到D节点；
    - D->C C为D的父节点；
- 这道题代码实现
```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
import java.util.Arrays;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if (pre.length == 0 || in.length == 0){
            return null;
        }
        TreeNode root = new TreeNode(pre[0]);
        int length = pre.length;
        for(int i = 0; i< length; i++){
            if(root.val == in[i]){
                // i之前为左子树
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i+1), Arrays.copyOfRange(in, 0, i));
                // i之后为右子树
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+1, length), Arrays.copyOfRange(in, i+1, length));
                break;
            }
        }
        return root;
    }
}
```
- 步骤：
    - 1.第一次切割后的左子树前序序列为：{2,4,7}，切割后的左子树中序序列为：{4,7,2}；切割后的右子树前序序列为：{3,5,6,8}，切割后的右子树中序序列为：{5,3,8,6} 
    - 2.第二次切割后的左子树前序序列为：{4,7},左子树中序序列为{4,7}


